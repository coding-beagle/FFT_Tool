<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>FFT Tool</h1>
    <div style="display: flex">
        <div>
            <h2>Time domain:</h2>
            <canvas id="timeDomain" width="600" height="500" style="border: 1px solid #000000;">
                This browser does not support canvas, please use one that does!
            </canvas>
        </div>
        <div style="padding-left: 0.5em">
            <h2>Frequency domain:</h2>
            <canvas id="freqDomain" width="600" height="500" style="border: 1px solid #000000;">
                This browser does not support canvas, please use one that does!
            </canvas>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('timeDomain');
        const ctx = canvas.getContext('2d');

        let startX, startY;
        let dragging = false;

        let cameraX = 250;
        let cameraY = 250;

        let prevCameraX = cameraX;
        let prevCameraY = cameraY;

        const CWIDTH = canvas.clientWidth;
        const CHEIGHT = canvas.clientHeight;

        const DENOMINATIONS_X = 10;
        const DENOMINATIONS_Y = 10;

        const drawLine = (x,y,x_end,y_end, colour, thickness=1) => {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x_end, y_end);
            ctx.lineWidth = thickness;
            ctx.strokeStyle = colour;
            ctx.stroke();
        }

        const convertCartesianToCanvasCoords = (x,y) => {
            
        } 

        const redrawGridWithCamera = () => {
            ctx.clearRect(0, 0, CWIDTH, CHEIGHT);

            const distance_between_denoms_x = CWIDTH / DENOMINATIONS_X;
            const distance_between_denoms_y = CHEIGHT / DENOMINATIONS_Y;


            const startGridX = Math.floor(-cameraX / distance_between_denoms_x);
            const startGridY = Math.floor(-cameraY / distance_between_denoms_y);

            for(let i = startGridX; i <= startGridX + DENOMINATIONS_X + 1; i++){
                console.log(i);
                const x_val = i * distance_between_denoms_x + cameraX;
                if(x_val >= 0 && x_val <= CWIDTH) {
                    const colour = (i === 0) ? 'black' : 'blue'
                    const thickness = (i === 0) ? 2 : 1;
                    drawLine(x_val, 0, x_val, CHEIGHT, colour, thickness);
                }
            }

            for(let i = startGridY; i <= startGridY + DENOMINATIONS_Y + 1; i++){
                const y_val = i * distance_between_denoms_y + cameraY;
                if(y_val >= 0 && y_val <= CHEIGHT) {
                    const colour = (i === 0) ? 'black' : 'blue';
                    const thickness = (i === 0) ? 2 : 1;
                    drawLine(0, y_val, CWIDTH, y_val, colour, thickness);
                }
            }
        }

        const handleMouseDown = (event) => {
            dragging = true;
            startX = event.clientX;
            startY = event.clientY;

            prevCameraX = cameraX;
            prevCameraY = cameraY;
        }

        const handleMouseUp = () => {
            dragging = false;
        }

        const handleMouseMove = (event) => {
            if(dragging){
                cameraX = prevCameraX + event.clientX - startX;
                cameraY = prevCameraY + event.clientY - startY;
                redrawGridWithCamera();
            }
        }

        redrawGridWithCamera();

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mousemove', handleMouseMove);


    </script>
</body>
</html>